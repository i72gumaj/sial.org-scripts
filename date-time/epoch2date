#!/usr/bin/env perl
#
# Converts epoch times to human parsable dates. Accepts list of epoch
# dates (integers) usually via arguments:
#
#   epoch2date `perl -E 'say time'`
#   echo 1059673440 | xargs epoch2date
#   echo 1059673440 1404433529 | epoch2date -
#
# The author disclaims all copyrights and releases this script into the
# public domain.

use strict;
use warnings;

use File::Basename qw(basename);
use POSIX qw(strftime);

my $basename = basename $0;

use Getopt::Std;
my %opts;
getopts( 'h?f:gl', \%opts );

if ( not @ARGV or exists $opts{h} or exists $opts{'?'} ) {
  warn "Usage: $basename [-f strftime] [-g|-l] [epoch [epoch ...]|-]\n";
  exit 64;
}

my $format = $opts{f} || '%Y-%m-%d %H:%M:%S %Z';
$format =~ s/(\\.)/qq!"$1"!/eeg;

my $timefunc = sub { localtime $_[0] };
$timefunc = sub { gmtime $_[0] }
  if $basename eq 'epoch2gmdate';
$timefunc = sub { localtime $_[0] }
  if exists $opts{l};
$timefunc = sub { gmtime $_[0] }
  if exists $opts{g};

# but use xargs or the like if there is lots of input
@ARGV = <STDIN> if $ARGV[0] eq '-';

for my $entry (@ARGV) {
  # negative epoch dubious? but why not
  for my $epoch ( $entry =~ m/(-?[0-9]+)/g ) {
    print strftime( $format, $timefunc->($epoch) ), "\n";
  }
}

END {
  # Report problems when writing to stdout (perldoc perlopentut)
  unless ( close(STDOUT) ) {
    warn "error: problem closing STDOUT: $!\n";
    exit 74;
  }
}
